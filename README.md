# m3_project

## Проблемы, мысли и пр.

- Под Windows библиотеки, ожидаемо, не устанавливаются. Была поднята виртуальная машина с Ubuntu, проект создан на ней, в Pycharm на Windows настроено подключение к удалённому интерпретатору по SSH.
- Django по умолчанию запускает сервер на 127.0.0.1, что предотвращало доступ к сайту из Windows. В настройках конфигурации запуска установил 0.0.0.0 в качестве хоста.
- При попытке запустить приложение на 5 шаге получаю ошибку о невозможности импортировать `Mapping` из модуля `collections`. Насколько я понял, это связано с перемещением этого класса в `collections.abc` в Python 3.10. Пришлось дополнительно устанавливать в систему Python 3.9 и пересоздавать виртуальное окружение уже с него. Как бы не пришлось до 3.6 откатываться из-за других несовместимостей.
- В документации `m3-core` и `objectpack` много пропусков, некоторые вещи вообще не указаны, другие упоминаются лишь вскользь. Некоторые примеры оттуда содержат ошибки или просто не работают.
  - Принцип добавления действий в меню не объясняется подробно.
  - Не отмечена необходимость использования `/` в url actionpack-ов (возможно, имеет смысл только при условии использования `objectpack`, но привело к нескольким заминкам).
  - Использование `observer`-а в качестве реестра при создании окон модели так же не указано (потребовалось погружение в исходный код и подробный референс библиотеки, чтобы обнаружить такую возможность).
  - Важные для настройки полей (из `m3_ext`) аргументы так же не указаны и их пришлось искать в исходном коде самих полей.
- Формат даты по умолчанию для `ExtDateField` почему-то не работает и его нужно указывать явно.
- Где `ExtDateTimeField`?
- В целом создание окна редактирования для модели пользователя не вызвало затруднений, но сам подход мне не очень нравится. Не все поля, создаваемые фабричным методом имеет смысл указывать: 
  - Поля `date_joined` и `last_login` - служебные, и, по-хорошему, не должны быть редактируемы вручную.
  - Поле `password` тоже спорно. С одной стороны, отображается в нём хеш, с другой - задавать то его стоит текстом. Я сделал простую постобработку, которая проверяет наличие сырого текста в поле и хеширует его (через `make_password` из `Django`), но я не уверен, что стоит так делать. Возможно имеет смысл наличие псевдо-поля `new_password`, текст из которого, при наличии, будет хешироваться и сохраняться в `password`
